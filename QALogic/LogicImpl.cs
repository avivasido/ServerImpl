using Constants;
using Entities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QALogic
{
    public class LogicImpl : ILogic
    {
        private MedTrainDBContext _db;

        public LogicImpl(MedTrainDBContext db)
        {
            _db = db;
        }

        public Question getAutoGeneratedQuestion(string subject, string topic, bool subjectProvided, bool topicProvided, int userLvl)
        {
            Tuple<string, List<Question>> questions = getAutoGeneratedTest(subject, topic, subjectProvided, topicProvided, userLvl, 1);
            if (!questions.Item1.Equals(Replies.SUCCESS))
            {
                return null;
            }
            return selectRandomObject<Question>(questions.Item2);
        }

        public Tuple<string, List<Question>> getAutoGeneratedTest(string subject, string topic, bool subjectProvided, bool topicProvided, int userLvl, int numOfQuestions)
        {
            // get all questions with a matching topic and subject
            List<Question> questions = _db.getQuestions(subject, topic);
            // if there is no question matching the given subject and topic
            if (questions.Count < numOfQuestions && subjectProvided && topicProvided)
            {
                return new Tuple<string, List<Question>>("Error - the provided subject and topic does not have enough questions.", null);
            }
            List<Topic> topics = _db.getTopics(subject);
            string givenTopic = topic;
            // while there is no question re-select subjct and/or topic
            // try finding enough questions of the same subject
            List<Question> test = new List<Question>();
            foreach (Topic t in topics)
            {
                test.AddRange(_db.getQuestions(subject, topic));
                if (questions.Count >= numOfQuestions)
                {
                    break;
                }
            }
            // if there are no enough questions matching the given subject
            if (questions.Count < numOfQuestions && subjectProvided)
            {
                return new Tuple<string, List<Question>>("Error - the provided subject does not have enough questions.", null);
            }
            // iterate over all subjects and topics to find enough questions
            List<Subject> subjects = _db.getSubjects();
            string givenSubject = subject;
            foreach (Subject s in subjects)
            {
                if (s.SubjectId.Equals(givenSubject))
                {
                    continue;
                }
                topics = _db.getTopics(s.SubjectId);
                foreach (Topic t in topics)
                {
                    test.AddRange(_db.getQuestions(subject, topic));
                    if (questions.Count >= numOfQuestions)
                    {
                        break;
                    }
                }
                if (questions.Count >= numOfQuestions)
                {
                    break;
                }
            }
            if (questions.Count < numOfQuestions)
            {
                return new Tuple<string, List<Question>>("Error - there are no enough questions in the system.", null);
            }
            // select the appropriate amount of random questions
            //List<Question> test = new List<Question>();
            for (int i = 0; i < numOfQuestions; i++)
            {
                // should see if there are questions of the relevant level
                // if so, prefer those the user did not answer
                // if answered all of them, select from those answered over a week ago
                // if none apply, increase level range from [a,b] to [a-1,b+1]
                Question q = selectRandomObject<Question>(questions);
                questions.Remove(q);
                test.Add(q);
            }
            return new Tuple<string, List<Question>>(Replies.SUCCESS, test);
        }

        public string answerAQuestion(string eMail, Question q, UserLevel userLVL, bool isNormal, int normalityCertaintyLVL, List<string> diagnoses, List<int> diagnosisCertainties)
        {
            bool correctAnswer = isNormal == q.normal;
            if (correctAnswer && !q.normal)
            {
                foreach (string s in q.diagnoses)
                {
                    if (!diagnoses.Contains(s))
                    {
                        correctAnswer = false;
                        break;
                    }
                }
                if (correctAnswer)
                {
                    foreach (string s in diagnoses)
                    {
                        if (!q.diagnoses.Contains(s))
                        {
                            correctAnswer = false;
                            break;
                        }
                    }
                }
            }
            // create a new answer instance and save to DB
            ICollection<Tuple<string, int>> diagnosesCertaintyLVL = new List<Tuple<string, int>>();
            for (int i = 0; i < diagnoses.Count; i++)
            {
                diagnosesCertaintyLVL.Add(new Tuple<string, int>(diagnoses.ElementAt(i), diagnosisCertainties.ElementAt(0)));
            }
            Answer a = new Answer
            {
                questionId = q.QuestionId,
                userId = eMail,
                timeAdded = DateTime.Now,
                questionLevel = q.level,
                userLevel = userLVL.level,
                isCorrectAnswer = correctAnswer,
                normal = isNormal,
                normalityCertainty = normalityCertaintyLVL,
                diagnoses = null
            };
            if (!_db.addAnswer(a))
            {
                return "Error - could not save the given answer.";
            }
            // update question's fields
            q.timesAnswered++;
            if (correctAnswer)
            {
                q.timesAnsweredCorrectly++;
            }
            // update users level's fields
            userLVL.timesAnswered++;
            if (correctAnswer)
            {
                userLVL.timesAnsweredCorrectly++;
            }
            _db.Entry(q).State = System.Data.Entity.EntityState.Modified;
            _db.Entry(userLVL).State = System.Data.Entity.EntityState.Modified;
            _db.SaveChanges();
            return Replies.SUCCESS;
            // update user and question level if needed
        }

        private T selectRandomObject<T>(List<T> l)
        {
            Random rnd = new Random();
            return l.ElementAt(rnd.Next(l.Count));
        }
    }
}
